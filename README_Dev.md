## PreferencesEvery experiment relies on a series resistor. Therefore the `Model` contains a reference to the `seriesResistance` member can can be used by all subclasses.# Create install files for all 3 operating systems## JavaPackager1. <https://medium.com/@adam_carroll/java-packager-with-jdk11-31b3d620f4a8>### JDEPSTo find out which JRE deps are needed```bash/Library/Java/JavaVirtualMachines/openjdk-11.0.2.jdk/Contents/Home/bin/jdeps --list-deps /Users/timmolter/workspaces/workspace_knowm/memristor-discovery/jar/memristor-discovery-2.0.0.jar```[Source](https://medium.com/azulsystems/using-jlink-to-build-java-runtimes-for-non-modular-applications-9568c5e70ef4)### MacOS[Download](https://mail.openjdk.java.net/pipermail/openjfx-dev/2018-September/022500.html) the MacOS binary and place in `usr/local/Cellar`.```brew cask install javanano ~/.bash_profileexport JAVA_HOME=`/usr/libexec/java_home`echo $JAVA_HOME /usr/local/Cellar/jdk.packager-osx/jpackager --version``````mvn clean package```Move jar to `jar` folder manually. It needs to be isolated like this in order for `jpackager` to only pull in the jar into the final package.```cd ~/workspaces/workspace_knowm/memristor-discovery./package_macos.sh```### WindowsFor Windows, when you unpack the Java Packager bundle you’ll find two files inside. I found that I needed to move these two files into the following directories inside the JDK itself:    jpackager.exe ➔ %JAVA_HOME%\bin    jdk.packager.jar ➔ %JAVA_HOME%\jmods    `MSVCP140.dll` and `VCRUNTIME140.dll` are needed both for the packaging process and for the final running program. The files are available as a download [here](https://www.microsoft.com/en-us/download/details.aspx?id=48145) on the Microsoft website. The Microsoft installer places the missing DLL files into C:\Windows\System32.To build the installable bundle on Windows, we need the [Inno Setup software](http://www.jrsoftware.org/isdl.php).```cd .../memristor-discoverypackage_windows.bat```Open the *.iss file in Inno Setup and hit run. An installer will be created in `target/Output`.### Linux[Download](https://mail.openjdk.java.net/pipermail/openjfx-dev/2018-September/022500.html) the Linux binary and place in `/usr/local/bin/jpackager`. There are two files: `jdk.packager.jar` and `jpackager`. ```cd /usr/local/binsudo chmod 777 jpackager/usr/local/bin/jpackager/jpackager --version``````mvn package```Move jar to `jar` folder manually. It needs to be isolated like this in order for `jpackager` to only pull in the jar into the final package.```cd ~/Github/memristor-discovery./package_linux.sh``````sudo apt install ./target/memristor-discovery-2.0.0.deb```## Code Formatting#### MavenWe use the [fmt-maven-plugin](https://github.com/coveo/fmt-maven-plugin), which can be invoked at the command line via:     mvn com.coveo:fmt-maven-plugin:format    Formats your code using [google-java-format](https://github.com/google/google-java-format) which follows [Google's code styleguide](https://google.github.io/styleguide/javaguide.html).If you want your IDE to stick to the same format, check out the available configuration plugins:#### EclipseDownload [`google-java-format-eclipse-plugin_*.jar`](https://github.com/google/google-java-format/releases) and place in `/Applications/Eclipse Java.app/Contents/Eclipse/dropins`. Restart Eclipse. Select the plugin in `Preferences > Java > Code Style > Formatter > Formatter Implementation`. #### IntelliJIn the plugins section in IntelliJ search for `google-java-format` and install the plugin. Restart IntelliJ.## Java Preferences=======# Experiment Structure## PreferencesEvery experiment relies on a series resistor. Therefore the `Model` contains a reference to the `seriesResistance` member can can be used by all subclasses.